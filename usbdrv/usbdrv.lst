GAS LISTING /tmp/ccupxjDr.s 			page 1


   1               		.file	"usbdrv.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.stabs	"/home/joaquin/Escritorio/vusbtiny (2)/",100,0,2,.Ltext0
   8               		.stabs	"usbdrv/usbdrv.c",100,0,2,.Ltext0
   9               		.text
  10               	.Ltext0:
  11               		.stabs	"gcc2_compiled.",60,0,0,0
  12               		.stabs	"int:t(0,1)=r(0,1);-32768;32767;",128,0,0,0
  13               		.stabs	"char:t(0,2)=@s8;r(0,2);0;255;",128,0,0,0
  14               		.stabs	"long int:t(0,3)=@s32;r(0,3);020000000000;017777777777;",128,0,0,0
  15               		.stabs	"unsigned int:t(0,4)=r(0,4);0;0177777;",128,0,0,0
  16               		.stabs	"long unsigned int:t(0,5)=@s32;r(0,5);0;037777777777;",128,0,0,0
  17               		.stabs	"long long int:t(0,6)=@s64;r(0,6);01000000000000000000000;0777777777777777777777;",128,0,0,
  18               		.stabs	"long long unsigned int:t(0,7)=@s64;r(0,7);0;01777777777777777777777;",128,0,0,0
  19               		.stabs	"short int:t(0,8)=r(0,8);-32768;32767;",128,0,0,0
  20               		.stabs	"short unsigned int:t(0,9)=r(0,9);0;0177777;",128,0,0,0
  21               		.stabs	"signed char:t(0,10)=@s8;r(0,10);-128;127;",128,0,0,0
  22               		.stabs	"unsigned char:t(0,11)=@s8;r(0,11);0;255;",128,0,0,0
  23               		.stabs	"float:t(0,12)=r(0,1);4;0;",128,0,0,0
  24               		.stabs	"double:t(0,13)=r(0,1);4;0;",128,0,0,0
  25               		.stabs	"long double:t(0,14)=r(0,1);4;0;",128,0,0,0
  26               		.stabs	"short _Fract:t(0,15)=r(0,1);1;0;",128,0,0,0
  27               		.stabs	"_Fract:t(0,16)=r(0,1);2;0;",128,0,0,0
  28               		.stabs	"long _Fract:t(0,17)=r(0,1);4;0;",128,0,0,0
  29               		.stabs	"long long _Fract:t(0,18)=r(0,1);8;0;",128,0,0,0
  30               		.stabs	"unsigned short _Fract:t(0,19)=r(0,1);1;0;",128,0,0,0
  31               		.stabs	"unsigned _Fract:t(0,20)=r(0,1);2;0;",128,0,0,0
  32               		.stabs	"unsigned long _Fract:t(0,21)=r(0,1);4;0;",128,0,0,0
  33               		.stabs	"unsigned long long _Fract:t(0,22)=r(0,1);8;0;",128,0,0,0
  34               		.stabs	"_Sat short _Fract:t(0,23)=r(0,1);1;0;",128,0,0,0
  35               		.stabs	"_Sat _Fract:t(0,24)=r(0,1);2;0;",128,0,0,0
  36               		.stabs	"_Sat long _Fract:t(0,25)=r(0,1);4;0;",128,0,0,0
  37               		.stabs	"_Sat long long _Fract:t(0,26)=r(0,1);8;0;",128,0,0,0
  38               		.stabs	"_Sat unsigned short _Fract:t(0,27)=r(0,1);1;0;",128,0,0,0
  39               		.stabs	"_Sat unsigned _Fract:t(0,28)=r(0,1);2;0;",128,0,0,0
  40               		.stabs	"_Sat unsigned long _Fract:t(0,29)=r(0,1);4;0;",128,0,0,0
  41               		.stabs	"_Sat unsigned long long _Fract:t(0,30)=r(0,1);8;0;",128,0,0,0
  42               		.stabs	"short _Accum:t(0,31)=r(0,1);2;0;",128,0,0,0
  43               		.stabs	"_Accum:t(0,32)=r(0,1);4;0;",128,0,0,0
  44               		.stabs	"long _Accum:t(0,33)=r(0,1);8;0;",128,0,0,0
  45               		.stabs	"long long _Accum:t(0,34)=r(0,1);8;0;",128,0,0,0
  46               		.stabs	"unsigned short _Accum:t(0,35)=r(0,1);2;0;",128,0,0,0
  47               		.stabs	"unsigned _Accum:t(0,36)=r(0,1);4;0;",128,0,0,0
  48               		.stabs	"unsigned long _Accum:t(0,37)=r(0,1);8;0;",128,0,0,0
  49               		.stabs	"unsigned long long _Accum:t(0,38)=r(0,1);8;0;",128,0,0,0
  50               		.stabs	"_Sat short _Accum:t(0,39)=r(0,1);2;0;",128,0,0,0
  51               		.stabs	"_Sat _Accum:t(0,40)=r(0,1);4;0;",128,0,0,0
  52               		.stabs	"_Sat long _Accum:t(0,41)=r(0,1);8;0;",128,0,0,0
  53               		.stabs	"_Sat long long _Accum:t(0,42)=r(0,1);8;0;",128,0,0,0
  54               		.stabs	"_Sat unsigned short _Accum:t(0,43)=r(0,1);2;0;",128,0,0,0
  55               		.stabs	"_Sat unsigned _Accum:t(0,44)=r(0,1);4;0;",128,0,0,0
  56               		.stabs	"_Sat unsigned long _Accum:t(0,45)=r(0,1);8;0;",128,0,0,0
  57               		.stabs	"_Sat unsigned long long _Accum:t(0,46)=r(0,1);8;0;",128,0,0,0
GAS LISTING /tmp/ccupxjDr.s 			page 2


  58               		.stabs	"void:t(0,47)=(0,47)",128,0,0,0
  59               		.stabs	"usbdrv/usbportability.h",130,0,0,0
  60               		.stabs	"/usr/lib/avr/include/avr/io.h",130,0,0,0
  61               		.stabs	"/usr/lib/avr/include/avr/sfr_defs.h",130,0,0,0
  62               		.stabs	"/usr/lib/avr/include/inttypes.h",130,0,0,0
  63               		.stabs	"/usr/lib/gcc/avr/4.8.1/include/stdint.h",130,0,0,0
  64               		.stabs	"/usr/lib/avr/include/stdint.h",130,0,0,0
  65               		.stabs	"int8_t:t(6,1)=(0,10)",128,0,121,0
  66               		.stabs	"uint8_t:t(6,2)=(0,11)",128,0,122,0
  67               		.stabs	"int16_t:t(6,3)=(0,1)",128,0,123,0
  68               		.stabs	"uint16_t:t(6,4)=(0,4)",128,0,124,0
  69               		.stabs	"int32_t:t(6,5)=(0,3)",128,0,125,0
  70               		.stabs	"uint32_t:t(6,6)=(0,5)",128,0,126,0
  71               		.stabs	"int64_t:t(6,7)=(0,6)",128,0,128,0
  72               		.stabs	"uint64_t:t(6,8)=(0,7)",128,0,129,0
  73               		.stabs	"intptr_t:t(6,9)=(6,3)",128,0,142,0
  74               		.stabs	"uintptr_t:t(6,10)=(6,4)",128,0,147,0
  75               		.stabs	"int_least8_t:t(6,11)=(6,1)",128,0,159,0
  76               		.stabs	"uint_least8_t:t(6,12)=(6,2)",128,0,164,0
  77               		.stabs	"int_least16_t:t(6,13)=(6,3)",128,0,169,0
  78               		.stabs	"uint_least16_t:t(6,14)=(6,4)",128,0,174,0
  79               		.stabs	"int_least32_t:t(6,15)=(6,5)",128,0,179,0
  80               		.stabs	"uint_least32_t:t(6,16)=(6,6)",128,0,184,0
  81               		.stabs	"int_least64_t:t(6,17)=(6,7)",128,0,192,0
  82               		.stabs	"uint_least64_t:t(6,18)=(6,8)",128,0,199,0
  83               		.stabs	"int_fast8_t:t(6,19)=(6,1)",128,0,213,0
  84               		.stabs	"uint_fast8_t:t(6,20)=(6,2)",128,0,218,0
  85               		.stabs	"int_fast16_t:t(6,21)=(6,3)",128,0,223,0
  86               		.stabs	"uint_fast16_t:t(6,22)=(6,4)",128,0,228,0
  87               		.stabs	"int_fast32_t:t(6,23)=(6,5)",128,0,233,0
  88               		.stabs	"uint_fast32_t:t(6,24)=(6,6)",128,0,238,0
  89               		.stabs	"int_fast64_t:t(6,25)=(6,7)",128,0,246,0
  90               		.stabs	"uint_fast64_t:t(6,26)=(6,8)",128,0,253,0
  91               		.stabs	"intmax_t:t(6,27)=(6,7)",128,0,273,0
  92               		.stabs	"uintmax_t:t(6,28)=(6,8)",128,0,278,0
  93               		.stabn	162,0,0,0
  94               		.stabn	162,0,0,0
  95               		.stabs	"int_farptr_t:t(4,1)=(6,5)",128,0,77,0
  96               		.stabs	"uint_farptr_t:t(4,2)=(6,6)",128,0,81,0
  97               		.stabn	162,0,0,0
  98               		.stabn	162,0,0,0
  99               		.stabs	"/usr/lib/avr/include/avr/fuse.h",130,0,0,0
 100               		.stabs	"__fuse_t:t(7,1)=(7,2)=s3low:(0,11),0,8;high:(0,11),8,8;extended:(0,11),16,8;;",128,0,244,0
 101               		.stabn	162,0,0,0
 102               		.stabn	162,0,0,0
 103               		.stabs	"/usr/lib/avr/include/avr/pgmspace.h",130,0,0,0
 104               		.stabs	"/usr/lib/gcc/avr/4.8.1/include/stddef.h",130,0,0,0
 105               		.stabs	"size_t:t(9,1)=(0,4)",128,0,212,0
 106               		.stabn	162,0,0,0
 107               		.stabn	162,0,0,0
 108               		.stabn	162,0,0,0
 109               		.stabs	"usbdrv/usbdrv.h",130,0,0,0
 110               		.stabs	"usbTxStatus:T(10,1)=s12len:(10,2)=B(0,11),0,8;buffer:(10,3)=ar(10,4)=r(10,4);0;0177777;;0;
 111               		.stabs	"usbTxStatus_t:t(10,5)=(10,1)",128,0,650,0
 112               		.stabs	"usbWord:T(10,6)=u2word:(0,4),0,16;bytes:(10,7)=ar(10,4);0;1;(0,11),0,16;;",128,0,0,0
 113               		.stabs	"usbWord_t:t(10,8)=(10,6)",128,0,662,0
 114               		.stabs	"usbRequest:T(10,9)=s8bmRequestType:(0,11),0,8;bRequest:(0,11),8,8;wValue:(10,8),16,16;wInd
GAS LISTING /tmp/ccupxjDr.s 			page 3


 115               		.stabs	"usbRequest_t:t(10,10)=(10,9)",128,0,670,0
 116               		.stabn	162,0,0,0
 117               		.stabs	"usbSetInterrupt:F(0,47)",36,0,245,usbSetInterrupt
 118               		.stabs	"len:P(0,11)",64,0,245,28
 119               	.global	usbSetInterrupt
 120               		.type	usbSetInterrupt, @function
 121               	usbSetInterrupt:
 122               		.stabd	46,0,0
   1:usbdrv/usbdrv.c **** /* Name: usbdrv.c
   2:usbdrv/usbdrv.c ****  * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
   3:usbdrv/usbdrv.c ****  * Author: Christian Starkjohann
   4:usbdrv/usbdrv.c ****  * Creation Date: 2004-12-29
   5:usbdrv/usbdrv.c ****  * Tabsize: 4
   6:usbdrv/usbdrv.c ****  * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
   7:usbdrv/usbdrv.c ****  * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
   8:usbdrv/usbdrv.c ****  * This Revision: $Id: usbdrv.c 763 2009-08-22 10:27:24Z cs $
   9:usbdrv/usbdrv.c ****  */
  10:usbdrv/usbdrv.c **** 
  11:usbdrv/usbdrv.c **** #include "usbportability.h"
  12:usbdrv/usbdrv.c **** #include "usbdrv.h"
  13:usbdrv/usbdrv.c **** #include "oddebug.h"
  14:usbdrv/usbdrv.c **** 
  15:usbdrv/usbdrv.c **** /*
  16:usbdrv/usbdrv.c **** General Description:
  17:usbdrv/usbdrv.c **** This module implements the C-part of the USB driver. See usbdrv.h for a
  18:usbdrv/usbdrv.c **** documentation of the entire driver.
  19:usbdrv/usbdrv.c **** */
  20:usbdrv/usbdrv.c **** 
  21:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
  22:usbdrv/usbdrv.c **** 
  23:usbdrv/usbdrv.c **** /* raw USB registers / interface to assembler code: */
  24:usbdrv/usbdrv.c **** uchar usbRxBuf[2*USB_BUFSIZE];  /* raw RX buffer: PID, 8 bytes data, 2 bytes CRC */
  25:usbdrv/usbdrv.c **** uchar       usbInputBufOffset;  /* offset in usbRxBuf used for low level receiving */
  26:usbdrv/usbdrv.c **** uchar       usbDeviceAddr;      /* assigned during enumeration, defaults to 0 */
  27:usbdrv/usbdrv.c **** uchar       usbNewDeviceAddr;   /* device ID which should be set after status phase */
  28:usbdrv/usbdrv.c **** uchar       usbConfiguration;   /* currently selected configuration. Administered by driver, but no
  29:usbdrv/usbdrv.c **** volatile schar usbRxLen;        /* = 0; number of bytes in usbRxBuf; 0 means free, -1 for flow cont
  30:usbdrv/usbdrv.c **** uchar       usbCurrentTok;      /* last token received or endpoint number for last OUT token if != 
  31:usbdrv/usbdrv.c **** uchar       usbRxToken;         /* token for data we received; or endpont number for last OUT */
  32:usbdrv/usbdrv.c **** volatile uchar usbTxLen = USBPID_NAK;   /* number of bytes to transmit with next IN token or handsh
  33:usbdrv/usbdrv.c **** uchar       usbTxBuf[USB_BUFSIZE];/* data to transmit with next IN, free if usbTxLen contains hands
  34:usbdrv/usbdrv.c **** #if USB_COUNT_SOF
  35:usbdrv/usbdrv.c **** volatile uchar  usbSofCount;    /* incremented by assembler module every SOF */
  36:usbdrv/usbdrv.c **** #endif
  37:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
  38:usbdrv/usbdrv.c **** usbTxStatus_t  usbTxStatus1;
  39:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
  40:usbdrv/usbdrv.c **** usbTxStatus_t  usbTxStatus3;
  41:usbdrv/usbdrv.c **** #   endif
  42:usbdrv/usbdrv.c **** #endif
  43:usbdrv/usbdrv.c **** #if USB_CFG_CHECK_DATA_TOGGLING
  44:usbdrv/usbdrv.c **** uchar       usbCurrentDataToken;/* when we check data toggling to ignore duplicate packets */
  45:usbdrv/usbdrv.c **** #endif
  46:usbdrv/usbdrv.c **** 
  47:usbdrv/usbdrv.c **** /* USB status registers / not shared with asm code */
  48:usbdrv/usbdrv.c **** uchar               *usbMsgPtr;     /* data to transmit next -- ROM or RAM address */
  49:usbdrv/usbdrv.c **** static usbMsgLen_t  usbMsgLen = USB_NO_MSG; /* remaining number of bytes */
GAS LISTING /tmp/ccupxjDr.s 			page 4


  50:usbdrv/usbdrv.c **** static uchar        usbMsgFlags;    /* flag values see below */
  51:usbdrv/usbdrv.c **** 
  52:usbdrv/usbdrv.c **** #define USB_FLG_MSGPTR_IS_ROM   (1<<6)
  53:usbdrv/usbdrv.c **** #define USB_FLG_USE_USER_RW     (1<<7)
  54:usbdrv/usbdrv.c **** 
  55:usbdrv/usbdrv.c **** /*
  56:usbdrv/usbdrv.c **** optimizing hints:
  57:usbdrv/usbdrv.c **** - do not post/pre inc/dec integer values in operations
  58:usbdrv/usbdrv.c **** - assign value of USB_READ_FLASH() to register variables and don't use side effects in arg
  59:usbdrv/usbdrv.c **** - use narrow scope for variables which should be in X/Y/Z register
  60:usbdrv/usbdrv.c **** - assign char sized expressions to variables to force 8 bit arithmetics
  61:usbdrv/usbdrv.c **** */
  62:usbdrv/usbdrv.c **** 
  63:usbdrv/usbdrv.c **** /* -------------------------- String Descriptors --------------------------- */
  64:usbdrv/usbdrv.c **** 
  65:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS == 0
  66:usbdrv/usbdrv.c **** 
  67:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_0 == 0
  68:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_0
  69:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_0    sizeof(usbDescriptorString0)
  70:usbdrv/usbdrv.c **** const PROGMEM char usbDescriptorString0[] = { /* language descriptor */
  71:usbdrv/usbdrv.c ****     4,          /* sizeof(usbDescriptorString0): length of descriptor in bytes */
  72:usbdrv/usbdrv.c ****     3,          /* descriptor type */
  73:usbdrv/usbdrv.c ****     0x09, 0x04, /* language index (0x0409 = US-English) */
  74:usbdrv/usbdrv.c **** };
  75:usbdrv/usbdrv.c **** #endif
  76:usbdrv/usbdrv.c **** 
  77:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_VENDOR == 0 && USB_CFG_VENDOR_NAME_LEN
  78:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_VENDOR
  79:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_VENDOR   sizeof(usbDescriptorStringVendor)
  80:usbdrv/usbdrv.c **** const PROGMEM int  usbDescriptorStringVendor[] = {
  81:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_VENDOR_NAME_LEN),
  82:usbdrv/usbdrv.c ****     USB_CFG_VENDOR_NAME
  83:usbdrv/usbdrv.c **** };
  84:usbdrv/usbdrv.c **** #endif
  85:usbdrv/usbdrv.c **** 
  86:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_PRODUCT == 0 && USB_CFG_DEVICE_NAME_LEN
  87:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_PRODUCT
  88:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_PRODUCT   sizeof(usbDescriptorStringDevice)
  89:usbdrv/usbdrv.c **** const PROGMEM int  usbDescriptorStringDevice[] = {
  90:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_DEVICE_NAME_LEN),
  91:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_NAME
  92:usbdrv/usbdrv.c **** };
  93:usbdrv/usbdrv.c **** #endif
  94:usbdrv/usbdrv.c **** 
  95:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER == 0 && USB_CFG_SERIAL_NUMBER_LEN
  96:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
  97:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    sizeof(usbDescriptorStringSerialNumber)
  98:usbdrv/usbdrv.c **** PROGMEM int usbDescriptorStringSerialNumber[] = {
  99:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_SERIAL_NUMBER_LEN),
 100:usbdrv/usbdrv.c ****     USB_CFG_SERIAL_NUMBER
 101:usbdrv/usbdrv.c **** };
 102:usbdrv/usbdrv.c **** #endif
 103:usbdrv/usbdrv.c **** 
 104:usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS == 0 */
 105:usbdrv/usbdrv.c **** 
 106:usbdrv/usbdrv.c **** /* --------------------------- Device Descriptor --------------------------- */
GAS LISTING /tmp/ccupxjDr.s 			page 5


 107:usbdrv/usbdrv.c **** 
 108:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_DEVICE == 0
 109:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_DEVICE
 110:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_DEVICE  sizeof(usbDescriptorDevice)
 111:usbdrv/usbdrv.c **** const PROGMEM char usbDescriptorDevice[] = {    /* USB device descriptor */
 112:usbdrv/usbdrv.c ****     18,         /* sizeof(usbDescriptorDevice): length of descriptor in bytes */
 113:usbdrv/usbdrv.c ****     USBDESCR_DEVICE,        /* descriptor type */
 114:usbdrv/usbdrv.c ****     0x10, 0x01,             /* USB version supported */
 115:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_CLASS,
 116:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_SUBCLASS,
 117:usbdrv/usbdrv.c ****     0,                      /* protocol */
 118:usbdrv/usbdrv.c ****     8,                      /* max packet size */
 119:usbdrv/usbdrv.c ****     /* the following two casts affect the first byte of the constant only, but
 120:usbdrv/usbdrv.c ****      * that's sufficient to avoid a warning with the default values.
 121:usbdrv/usbdrv.c ****      */
 122:usbdrv/usbdrv.c ****     (char)USB_CFG_VENDOR_ID,/* 2 bytes */
 123:usbdrv/usbdrv.c ****     (char)USB_CFG_DEVICE_ID,/* 2 bytes */
 124:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_VERSION, /* 2 bytes */
 125:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         /* manufacturer string index */
 126:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        /* product string index */
 127:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  /* serial number string index */
 128:usbdrv/usbdrv.c ****     1,          /* number of configurations */
 129:usbdrv/usbdrv.c **** };
 130:usbdrv/usbdrv.c **** #endif
 131:usbdrv/usbdrv.c **** 
 132:usbdrv/usbdrv.c **** /* ----------------------- Configuration Descriptor ------------------------ */
 133:usbdrv/usbdrv.c **** 
 134:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT != 0 && USB_CFG_DESCR_PROPS_HID == 0
 135:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_HID
 136:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_HID     9   /* length of HID descriptor in config descriptor below */
 137:usbdrv/usbdrv.c **** #endif
 138:usbdrv/usbdrv.c **** 
 139:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_CONFIGURATION == 0
 140:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_CONFIGURATION
 141:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_CONFIGURATION   sizeof(usbDescriptorConfiguration)
 142:usbdrv/usbdrv.c **** const PROGMEM char usbDescriptorConfiguration[] = {    /* USB configuration descriptor */
 143:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */
 144:usbdrv/usbdrv.c ****     USBDESCR_CONFIG,    /* descriptor type */
 145:usbdrv/usbdrv.c ****     18 + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT3 +
 146:usbdrv/usbdrv.c ****                 (USB_CFG_DESCR_PROPS_HID & 0xff), 0,
 147:usbdrv/usbdrv.c ****                 /* total length of data returned (including inlined descriptors) */
 148:usbdrv/usbdrv.c ****     1,          /* number of interfaces in this configuration */
 149:usbdrv/usbdrv.c ****     1,          /* index of this configuration */
 150:usbdrv/usbdrv.c ****     0,          /* configuration name string index */
 151:usbdrv/usbdrv.c **** #if USB_CFG_IS_SELF_POWERED
 152:usbdrv/usbdrv.c ****     (1 << 7) | USBATTR_SELFPOWER,       /* attributes */
 153:usbdrv/usbdrv.c **** #else
 154:usbdrv/usbdrv.c ****     (1 << 7),                           /* attributes */
 155:usbdrv/usbdrv.c **** #endif
 156:usbdrv/usbdrv.c ****     USB_CFG_MAX_BUS_POWER/2,            /* max USB current in 2mA units */
 157:usbdrv/usbdrv.c **** /* interface descriptor follows inline: */
 158:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrInterface): length of descriptor in bytes */
 159:usbdrv/usbdrv.c ****     USBDESCR_INTERFACE, /* descriptor type */
 160:usbdrv/usbdrv.c ****     0,          /* index of this interface */
 161:usbdrv/usbdrv.c ****     0,          /* alternate setting for this interface */
 162:usbdrv/usbdrv.c ****     USB_CFG_HAVE_INTRIN_ENDPOINT + USB_CFG_HAVE_INTRIN_ENDPOINT3, /* endpoints excl 0: number of en
 163:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_CLASS,
GAS LISTING /tmp/ccupxjDr.s 			page 6


 164:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_SUBCLASS,
 165:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_PROTOCOL,
 166:usbdrv/usbdrv.c ****     0,          /* string index for interface */
 167:usbdrv/usbdrv.c **** #if (USB_CFG_DESCR_PROPS_HID & 0xff)    /* HID descriptor */
 168:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrHID): length of descriptor in bytes */
 169:usbdrv/usbdrv.c ****     USBDESCR_HID,   /* descriptor type: HID */
 170:usbdrv/usbdrv.c ****     0x01, 0x01, /* BCD representation of HID version */
 171:usbdrv/usbdrv.c ****     0x00,       /* target country code */
 172:usbdrv/usbdrv.c ****     0x01,       /* number of HID Report (or other HID class) Descriptor infos to follow */
 173:usbdrv/usbdrv.c ****     0x22,       /* descriptor type: report */
 174:usbdrv/usbdrv.c ****     USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  /* total length of report descriptor */
 175:usbdrv/usbdrv.c **** #endif
 176:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT    /* endpoint descriptor for endpoint 1 */
 177:usbdrv/usbdrv.c ****     7,          /* sizeof(usbDescrEndpoint) */
 178:usbdrv/usbdrv.c ****     USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
 179:usbdrv/usbdrv.c ****     (char)0x81, /* IN endpoint number 1 */
 180:usbdrv/usbdrv.c ****     0x03,       /* attrib: Interrupt endpoint */
 181:usbdrv/usbdrv.c ****     8, 0,       /* maximum packet size */
 182:usbdrv/usbdrv.c ****     USB_CFG_INTR_POLL_INTERVAL, /* in ms */
 183:usbdrv/usbdrv.c **** #endif
 184:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3   /* endpoint descriptor for endpoint 3 */
 185:usbdrv/usbdrv.c ****     7,          /* sizeof(usbDescrEndpoint) */
 186:usbdrv/usbdrv.c ****     USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
 187:usbdrv/usbdrv.c ****     (char)0x83, /* IN endpoint number 1 */
 188:usbdrv/usbdrv.c ****     0x03,       /* attrib: Interrupt endpoint */
 189:usbdrv/usbdrv.c ****     8, 0,       /* maximum packet size */
 190:usbdrv/usbdrv.c ****     USB_CFG_INTR_POLL_INTERVAL, /* in ms */
 191:usbdrv/usbdrv.c **** #endif
 192:usbdrv/usbdrv.c **** };
 193:usbdrv/usbdrv.c **** #endif
 194:usbdrv/usbdrv.c **** 
 195:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 196:usbdrv/usbdrv.c **** 
 197:usbdrv/usbdrv.c **** static inline void  usbResetDataToggling(void)
 198:usbdrv/usbdrv.c **** {
 199:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 200:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 201:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
 202:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 203:usbdrv/usbdrv.c **** #   endif
 204:usbdrv/usbdrv.c **** #endif
 205:usbdrv/usbdrv.c **** }
 206:usbdrv/usbdrv.c **** 
 207:usbdrv/usbdrv.c **** static inline void  usbResetStall(void)
 208:usbdrv/usbdrv.c **** {
 209:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT && USB_CFG_HAVE_INTRIN_ENDPOINT
 210:usbdrv/usbdrv.c ****         usbTxLen1 = USBPID_NAK;
 211:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 212:usbdrv/usbdrv.c ****         usbTxLen3 = USBPID_NAK;
 213:usbdrv/usbdrv.c **** #endif
 214:usbdrv/usbdrv.c **** #endif
 215:usbdrv/usbdrv.c **** }
 216:usbdrv/usbdrv.c **** 
 217:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 218:usbdrv/usbdrv.c **** 
 219:usbdrv/usbdrv.c **** #if !USB_CFG_SUPPRESS_INTR_CODE
 220:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT
GAS LISTING /tmp/ccupxjDr.s 			page 7


 221:usbdrv/usbdrv.c **** static void usbGenericSetInterrupt(uchar *data, uchar len, usbTxStatus_t *txStatus)
 222:usbdrv/usbdrv.c **** {
 223:usbdrv/usbdrv.c **** uchar   *p;
 224:usbdrv/usbdrv.c **** char    i;
 225:usbdrv/usbdrv.c **** 
 226:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 227:usbdrv/usbdrv.c ****     if(usbTxLen1 == USBPID_STALL)
 228:usbdrv/usbdrv.c ****         return;
 229:usbdrv/usbdrv.c **** #endif
 230:usbdrv/usbdrv.c ****     if(txStatus->len & 0x10){   /* packet buffer was empty */
 231:usbdrv/usbdrv.c ****         txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
 232:usbdrv/usbdrv.c ****     }else{
 233:usbdrv/usbdrv.c ****         txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
 234:usbdrv/usbdrv.c ****     }
 235:usbdrv/usbdrv.c ****     p = txStatus->buffer + 1;
 236:usbdrv/usbdrv.c ****     i = len;
 237:usbdrv/usbdrv.c ****     do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
 238:usbdrv/usbdrv.c ****         *p++ = *data++;
 239:usbdrv/usbdrv.c ****     }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
 240:usbdrv/usbdrv.c ****     usbCrc16Append(&txStatus->buffer[1], len);
 241:usbdrv/usbdrv.c ****     txStatus->len = len + 4;    /* len must be given including sync byte */
 242:usbdrv/usbdrv.c ****     DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
 243:usbdrv/usbdrv.c **** }
 244:usbdrv/usbdrv.c **** 
 245:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
 246:usbdrv/usbdrv.c **** {
 123               		.stabn	68,0,246,.LM0-.LFBB1
 124               	.LM0:
 125               	.LFBB1:
 126 0000 CF93      		push r28
 127               	/* prologue: function */
 128               	/* frame size = 0 */
 129               	/* stack size = 1 */
 130               	.L__stack_usage = 1
 131 0002 C62F      		mov r28,r22
 132               	.LBB22:
 133               	.LBB23:
 230:usbdrv/usbdrv.c ****         txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
 134               		.stabn	68,0,230,.LM1-.LFBB1
 135               	.LM1:
 136 0004 2091 0000 		lds r18,usbTxStatus1
 137 0008 24FF      		sbrs r18,4
 138 000a 00C0      		rjmp .L2
 231:usbdrv/usbdrv.c ****     }else{
 139               		.stabn	68,0,231,.LM2-.LFBB1
 140               	.LM2:
 141 000c 2091 0000 		lds r18,usbTxStatus1+1
 142 0010 38E8      		ldi r19,lo8(-120)
 143 0012 2327      		eor r18,r19
 144 0014 2093 0000 		sts usbTxStatus1+1,r18
 145 0018 00C0      		rjmp .L3
 146               	.L2:
 233:usbdrv/usbdrv.c ****     }
 147               		.stabn	68,0,233,.LM3-.LFBB1
 148               	.LM3:
 149 001a 2AE5      		ldi r18,lo8(90)
 150 001c 2093 0000 		sts usbTxStatus1,r18
GAS LISTING /tmp/ccupxjDr.s 			page 8


 151               	.L3:
 152 0020 DC01      		movw r26,r24
 153               	.LBE23:
 154               	.LBE22:
 155               		.stabn	68,0,246,.LM4-.LFBB1
 156               	.LM4:
 157 0022 E0E0      		ldi r30,lo8(usbTxStatus1+2)
 158 0024 F0E0      		ldi r31,hi8(usbTxStatus1+2)
 159 0026 8C2F      		mov r24,r28
 160 0028 8E0F      		add r24,r30
 161               	.L5:
 162               	.LBB25:
 163               	.LBB24:
 238:usbdrv/usbdrv.c ****     }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
 164               		.stabn	68,0,238,.LM5-.LFBB1
 165               	.LM5:
 166 002a 9D91      		ld r25,X+
 167 002c 9193      		st Z+,r25
 239:usbdrv/usbdrv.c ****     usbCrc16Append(&txStatus->buffer[1], len);
 168               		.stabn	68,0,239,.LM6-.LFBB1
 169               	.LM6:
 170 002e 8E13      		cpse r24,r30
 171 0030 00C0      		rjmp .L5
 240:usbdrv/usbdrv.c ****     txStatus->len = len + 4;    /* len must be given including sync byte */
 172               		.stabn	68,0,240,.LM7-.LFBB1
 173               	.LM7:
 174 0032 6C2F      		mov r22,r28
 175 0034 80E0      		ldi r24,lo8(usbTxStatus1+2)
 176 0036 90E0      		ldi r25,hi8(usbTxStatus1+2)
 177 0038 00D0      		rcall usbCrc16Append
 241:usbdrv/usbdrv.c ****     DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
 178               		.stabn	68,0,241,.LM8-.LFBB1
 179               	.LM8:
 180 003a CC5F      		subi r28,lo8(-(4))
 181 003c C093 0000 		sts usbTxStatus1,r28
 182               	/* epilogue start */
 183               	.LBE24:
 184               	.LBE25:
 247:usbdrv/usbdrv.c ****     usbGenericSetInterrupt(data, len, &usbTxStatus1);
 248:usbdrv/usbdrv.c **** }
 185               		.stabn	68,0,248,.LM9-.LFBB1
 186               	.LM9:
 187 0040 CF91      		pop r28
 188 0042 0895      		ret
 189               		.size	usbSetInterrupt, .-usbSetInterrupt
 190               	.Lscope1:
 191               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 192               		.stabd	78,0,0
 193               		.stabs	"usbPoll:F(0,47)",36,0,566,usbPoll
 194               	.global	usbPoll
 195               		.type	usbPoll, @function
 196               	usbPoll:
 197               		.stabd	46,0,0
 249:usbdrv/usbdrv.c **** #endif
 250:usbdrv/usbdrv.c **** 
 251:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 252:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
GAS LISTING /tmp/ccupxjDr.s 			page 9


 253:usbdrv/usbdrv.c **** {
 254:usbdrv/usbdrv.c ****     usbGenericSetInterrupt(data, len, &usbTxStatus3);
 255:usbdrv/usbdrv.c **** }
 256:usbdrv/usbdrv.c **** #endif
 257:usbdrv/usbdrv.c **** #endif /* USB_CFG_SUPPRESS_INTR_CODE */
 258:usbdrv/usbdrv.c **** 
 259:usbdrv/usbdrv.c **** /* ------------------ utilities for code following below ------------------- */
 260:usbdrv/usbdrv.c **** 
 261:usbdrv/usbdrv.c **** /* Use defines for the switch statement so that we can choose between an
 262:usbdrv/usbdrv.c ****  * if()else if() and a switch/case based implementation. switch() is more
 263:usbdrv/usbdrv.c ****  * efficient for a LARGE set of sequential choices, if() is better in all other
 264:usbdrv/usbdrv.c ****  * cases.
 265:usbdrv/usbdrv.c ****  */
 266:usbdrv/usbdrv.c **** #if USB_CFG_USE_SWITCH_STATEMENT
 267:usbdrv/usbdrv.c **** #   define SWITCH_START(cmd)       switch(cmd){{
 268:usbdrv/usbdrv.c **** #   define SWITCH_CASE(value)      }break; case (value):{
 269:usbdrv/usbdrv.c **** #   define SWITCH_CASE2(v1,v2)     }break; case (v1): case(v2):{
 270:usbdrv/usbdrv.c **** #   define SWITCH_CASE3(v1,v2,v3)  }break; case (v1): case(v2): case(v3):{
 271:usbdrv/usbdrv.c **** #   define SWITCH_DEFAULT          }break; default:{
 272:usbdrv/usbdrv.c **** #   define SWITCH_END              }}
 273:usbdrv/usbdrv.c **** #else
 274:usbdrv/usbdrv.c **** #   define SWITCH_START(cmd)       {uchar _cmd = cmd; if(0){
 275:usbdrv/usbdrv.c **** #   define SWITCH_CASE(value)      }else if(_cmd == (value)){
 276:usbdrv/usbdrv.c **** #   define SWITCH_CASE2(v1,v2)     }else if(_cmd == (v1) || _cmd == (v2)){
 277:usbdrv/usbdrv.c **** #   define SWITCH_CASE3(v1,v2,v3)  }else if(_cmd == (v1) || _cmd == (v2) || (_cmd == v3)){
 278:usbdrv/usbdrv.c **** #   define SWITCH_DEFAULT          }else{
 279:usbdrv/usbdrv.c **** #   define SWITCH_END              }}
 280:usbdrv/usbdrv.c **** #endif
 281:usbdrv/usbdrv.c **** 
 282:usbdrv/usbdrv.c **** #ifndef USB_RX_USER_HOOK
 283:usbdrv/usbdrv.c **** #define USB_RX_USER_HOOK(data, len)
 284:usbdrv/usbdrv.c **** #endif
 285:usbdrv/usbdrv.c **** #ifndef USB_SET_ADDRESS_HOOK
 286:usbdrv/usbdrv.c **** #define USB_SET_ADDRESS_HOOK()
 287:usbdrv/usbdrv.c **** #endif
 288:usbdrv/usbdrv.c **** 
 289:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 290:usbdrv/usbdrv.c **** 
 291:usbdrv/usbdrv.c **** /* We use if() instead of #if in the macro below because #if can't be used
 292:usbdrv/usbdrv.c ****  * in macros and the compiler optimizes constant conditions anyway.
 293:usbdrv/usbdrv.c ****  * This may cause problems with undefined symbols if compiled without
 294:usbdrv/usbdrv.c ****  * optimizing!
 295:usbdrv/usbdrv.c ****  */
 296:usbdrv/usbdrv.c **** #define GET_DESCRIPTOR(cfgProp, staticName)         \
 297:usbdrv/usbdrv.c ****     if(cfgProp){                                    \
 298:usbdrv/usbdrv.c ****         if((cfgProp) & USB_PROP_IS_RAM)             \
 299:usbdrv/usbdrv.c ****             flags = 0;                              \
 300:usbdrv/usbdrv.c ****         if((cfgProp) & USB_PROP_IS_DYNAMIC){        \
 301:usbdrv/usbdrv.c ****             len = usbFunctionDescriptor(rq);        \
 302:usbdrv/usbdrv.c ****         }else{                                      \
 303:usbdrv/usbdrv.c ****             len = USB_PROP_LENGTH(cfgProp);         \
 304:usbdrv/usbdrv.c ****             usbMsgPtr = (uchar *)(staticName);      \
 305:usbdrv/usbdrv.c ****         }                                           \
 306:usbdrv/usbdrv.c ****     }
 307:usbdrv/usbdrv.c **** 
 308:usbdrv/usbdrv.c **** /* usbDriverDescriptor() is similar to usbFunctionDescriptor(), but used
 309:usbdrv/usbdrv.c ****  * internally for all types of descriptors.
GAS LISTING /tmp/ccupxjDr.s 			page 10


 310:usbdrv/usbdrv.c ****  */
 311:usbdrv/usbdrv.c **** static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
 312:usbdrv/usbdrv.c **** {
 313:usbdrv/usbdrv.c **** usbMsgLen_t len = 0;
 314:usbdrv/usbdrv.c **** uchar       flags = USB_FLG_MSGPTR_IS_ROM;
 315:usbdrv/usbdrv.c **** 
 316:usbdrv/usbdrv.c ****     SWITCH_START(rq->wValue.bytes[1])
 317:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
 318:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 319:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 320:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 321:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 322:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
 323:usbdrv/usbdrv.c ****         if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
 324:usbdrv/usbdrv.c ****             flags = 0;
 325:usbdrv/usbdrv.c ****         len = usbFunctionDescriptor(rq);
 326:usbdrv/usbdrv.c **** #else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 327:usbdrv/usbdrv.c ****         SWITCH_START(rq->wValue.bytes[0])
 328:usbdrv/usbdrv.c ****         SWITCH_CASE(0)
 329:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 330:usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 331:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
 332:usbdrv/usbdrv.c ****         SWITCH_CASE(2)
 333:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
 334:usbdrv/usbdrv.c ****         SWITCH_CASE(3)
 335:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER, usbDescriptorStringSerialNumbe
 336:usbdrv/usbdrv.c ****         SWITCH_DEFAULT
 337:usbdrv/usbdrv.c ****             if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 338:usbdrv/usbdrv.c ****                 len = usbFunctionDescriptor(rq);
 339:usbdrv/usbdrv.c ****             }
 340:usbdrv/usbdrv.c ****         SWITCH_END
 341:usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 342:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
 343:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
 344:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
 345:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
 346:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
 347:usbdrv/usbdrv.c **** #endif
 348:usbdrv/usbdrv.c ****     SWITCH_DEFAULT
 349:usbdrv/usbdrv.c ****         if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 350:usbdrv/usbdrv.c ****             len = usbFunctionDescriptor(rq);
 351:usbdrv/usbdrv.c ****         }
 352:usbdrv/usbdrv.c ****     SWITCH_END
 353:usbdrv/usbdrv.c ****     usbMsgFlags = flags;
 354:usbdrv/usbdrv.c ****     return len;
 355:usbdrv/usbdrv.c **** }
 356:usbdrv/usbdrv.c **** 
 357:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 358:usbdrv/usbdrv.c **** 
 359:usbdrv/usbdrv.c **** /* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for
 360:usbdrv/usbdrv.c ****  * standard requests instead of class and custom requests.
 361:usbdrv/usbdrv.c ****  */
 362:usbdrv/usbdrv.c **** static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
 363:usbdrv/usbdrv.c **** {
 364:usbdrv/usbdrv.c **** uchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffe
 365:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 366:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
GAS LISTING /tmp/ccupxjDr.s 			page 11


 367:usbdrv/usbdrv.c **** uchar   index = rq->wIndex.bytes[0];
 368:usbdrv/usbdrv.c **** #endif
 369:usbdrv/usbdrv.c **** 
 370:usbdrv/usbdrv.c ****     dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
 371:usbdrv/usbdrv.c ****     SWITCH_START(rq->bRequest)
 372:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
 373:usbdrv/usbdrv.c ****         uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to
 374:usbdrv/usbdrv.c ****         if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)
 375:usbdrv/usbdrv.c ****             dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
 376:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 377:usbdrv/usbdrv.c ****         if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
 378:usbdrv/usbdrv.c ****             dataPtr[0] = usbTxLen1 == USBPID_STALL;
 379:usbdrv/usbdrv.c **** #endif
 380:usbdrv/usbdrv.c ****         dataPtr[1] = 0;
 381:usbdrv/usbdrv.c ****         len = 2;
 382:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 383:usbdrv/usbdrv.c ****     SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */
 384:usbdrv/usbdrv.c ****         if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
 385:usbdrv/usbdrv.c ****             usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
 386:usbdrv/usbdrv.c ****             usbResetDataToggling();
 387:usbdrv/usbdrv.c ****         }
 388:usbdrv/usbdrv.c **** #endif
 389:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
 390:usbdrv/usbdrv.c ****         usbNewDeviceAddr = value;
 391:usbdrv/usbdrv.c ****         USB_SET_ADDRESS_HOOK();
 392:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
 393:usbdrv/usbdrv.c ****         len = usbDriverDescriptor(rq);
 394:usbdrv/usbdrv.c ****         goto skipMsgPtrAssignment;
 395:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
 396:usbdrv/usbdrv.c ****         dataPtr = &usbConfiguration;  /* send current configuration value */
 397:usbdrv/usbdrv.c ****         len = 1;
 398:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
 399:usbdrv/usbdrv.c ****         usbConfiguration = value;
 400:usbdrv/usbdrv.c ****         usbResetStall();
 401:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
 402:usbdrv/usbdrv.c ****         len = 1;
 403:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 404:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
 405:usbdrv/usbdrv.c ****         usbResetDataToggling();
 406:usbdrv/usbdrv.c ****         usbResetStall();
 407:usbdrv/usbdrv.c **** #endif
 408:usbdrv/usbdrv.c ****     SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
 409:usbdrv/usbdrv.c ****         /* Should we add an optional hook here? */
 410:usbdrv/usbdrv.c ****     SWITCH_END
 411:usbdrv/usbdrv.c ****     usbMsgPtr = dataPtr;
 412:usbdrv/usbdrv.c **** skipMsgPtrAssignment:
 413:usbdrv/usbdrv.c ****     return len;
 414:usbdrv/usbdrv.c **** }
 415:usbdrv/usbdrv.c **** 
 416:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 417:usbdrv/usbdrv.c **** 
 418:usbdrv/usbdrv.c **** /* usbProcessRx() is called for every message received by the interrupt
 419:usbdrv/usbdrv.c ****  * routine. It distinguishes between SETUP and DATA packets and processes
 420:usbdrv/usbdrv.c ****  * them accordingly.
 421:usbdrv/usbdrv.c ****  */
 422:usbdrv/usbdrv.c **** static inline void usbProcessRx(uchar *data, uchar len)
 423:usbdrv/usbdrv.c **** {
GAS LISTING /tmp/ccupxjDr.s 			page 12


 424:usbdrv/usbdrv.c **** usbRequest_t    *rq = (void *)data;
 425:usbdrv/usbdrv.c **** 
 426:usbdrv/usbdrv.c **** /* usbRxToken can be:
 427:usbdrv/usbdrv.c ****  * 0x2d 00101101 (USBPID_SETUP for setup data)
 428:usbdrv/usbdrv.c ****  * 0xe1 11100001 (USBPID_OUT: data phase of setup transfer)
 429:usbdrv/usbdrv.c ****  * 0...0x0f for OUT on endpoint X
 430:usbdrv/usbdrv.c ****  */
 431:usbdrv/usbdrv.c ****     DBG2(0x10 + (usbRxToken & 0xf), data, len + 2); /* SETUP=1d, SETUP-DATA=11, OUTx=1x */
 432:usbdrv/usbdrv.c ****     USB_RX_USER_HOOK(data, len)
 433:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITEOUT
 434:usbdrv/usbdrv.c ****     if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
 435:usbdrv/usbdrv.c ****         usbFunctionWriteOut(data, len);
 436:usbdrv/usbdrv.c ****         return;
 437:usbdrv/usbdrv.c ****     }
 438:usbdrv/usbdrv.c **** #endif
 439:usbdrv/usbdrv.c ****     if(usbRxToken == (uchar)USBPID_SETUP){
 440:usbdrv/usbdrv.c ****         if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
 441:usbdrv/usbdrv.c ****             return;
 442:usbdrv/usbdrv.c ****         usbMsgLen_t replyLen;
 443:usbdrv/usbdrv.c ****         usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
 444:usbdrv/usbdrv.c ****         usbTxLen = USBPID_NAK;              /* abort pending transmit */
 445:usbdrv/usbdrv.c ****         usbMsgFlags = 0;
 446:usbdrv/usbdrv.c ****         uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
 447:usbdrv/usbdrv.c ****         if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
 448:usbdrv/usbdrv.c ****             replyLen = usbFunctionSetup(data);
 449:usbdrv/usbdrv.c **** 			// 2010.04.29 chrisc need this to work w/ usbtiny
 450:usbdrv/usbdrv.c ****         }else{
 451:usbdrv/usbdrv.c ****             replyLen = usbDriverSetup(rq);
 452:usbdrv/usbdrv.c ****         }
 453:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
 454:usbdrv/usbdrv.c ****         if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
 455:usbdrv/usbdrv.c ****             /* do some conditioning on replyLen, but on IN transfers only */
 456:usbdrv/usbdrv.c ****             if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
 457:usbdrv/usbdrv.c ****                 if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing *
 458:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.bytes[0];
 459:usbdrv/usbdrv.c ****                 }else{
 460:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.word;
 461:usbdrv/usbdrv.c ****                 }
 462:usbdrv/usbdrv.c ****             }
 463:usbdrv/usbdrv.c ****             usbMsgFlags = USB_FLG_USE_USER_RW;
 464:usbdrv/usbdrv.c ****         }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transf
 465:usbdrv/usbdrv.c **** #endif
 466:usbdrv/usbdrv.c ****         if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
 467:usbdrv/usbdrv.c ****             if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max 
 468:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.bytes[0];
 469:usbdrv/usbdrv.c ****         }else{
 470:usbdrv/usbdrv.c ****             if(replyLen > rq->wLength.word)     /* limit length to max */
 471:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.word;
 472:usbdrv/usbdrv.c ****         }
 473:usbdrv/usbdrv.c ****         usbMsgLen = replyLen;
 474:usbdrv/usbdrv.c ****     }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
 475:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITE
 476:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 477:usbdrv/usbdrv.c ****             uchar rval = usbFunctionWrite(data, len);
 478:usbdrv/usbdrv.c ****             if(rval == 0xff){   /* an error occurred */
 479:usbdrv/usbdrv.c ****                 usbTxLen = USBPID_STALL;
 480:usbdrv/usbdrv.c ****             }else if(rval != 0){    /* This was the final package */
GAS LISTING /tmp/ccupxjDr.s 			page 13


 481:usbdrv/usbdrv.c ****                 usbMsgLen = 0;  /* answer with a zero-sized data packet */
 482:usbdrv/usbdrv.c ****             }
 483:usbdrv/usbdrv.c ****         }
 484:usbdrv/usbdrv.c **** #endif
 485:usbdrv/usbdrv.c ****     }
 486:usbdrv/usbdrv.c **** }
 487:usbdrv/usbdrv.c **** 
 488:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 489:usbdrv/usbdrv.c **** 
 490:usbdrv/usbdrv.c **** /* This function is similar to usbFunctionRead(), but it's also called for
 491:usbdrv/usbdrv.c ****  * data handled automatically by the driver (e.g. descriptor reads).
 492:usbdrv/usbdrv.c ****  */
 493:usbdrv/usbdrv.c **** static uchar usbDeviceRead(uchar *data, uchar len)
 494:usbdrv/usbdrv.c **** {
 495:usbdrv/usbdrv.c ****     if(len > 0){    /* don't bother app with 0 sized reads */
 496:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ
 497:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 498:usbdrv/usbdrv.c ****             len = usbFunctionRead(data, len);
 499:usbdrv/usbdrv.c ****         }else
 500:usbdrv/usbdrv.c **** #endif
 501:usbdrv/usbdrv.c ****         {
 502:usbdrv/usbdrv.c ****             uchar i = len, *r = usbMsgPtr;
 503:usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 504:usbdrv/usbdrv.c ****                 do{
 505:usbdrv/usbdrv.c ****                     uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte
 506:usbdrv/usbdrv.c ****                     *data++ = c;
 507:usbdrv/usbdrv.c ****                     r++;
 508:usbdrv/usbdrv.c ****                 }while(--i);
 509:usbdrv/usbdrv.c ****             }else{  /* RAM data */
 510:usbdrv/usbdrv.c ****                 do{
 511:usbdrv/usbdrv.c ****                     *data++ = *r++;
 512:usbdrv/usbdrv.c ****                 }while(--i);
 513:usbdrv/usbdrv.c ****             }
 514:usbdrv/usbdrv.c ****             usbMsgPtr = r;
 515:usbdrv/usbdrv.c ****         }
 516:usbdrv/usbdrv.c ****     }
 517:usbdrv/usbdrv.c ****     return len;
 518:usbdrv/usbdrv.c **** }
 519:usbdrv/usbdrv.c **** 
 520:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 521:usbdrv/usbdrv.c **** 
 522:usbdrv/usbdrv.c **** /* usbBuildTxBlock() is called when we have data to transmit and the
 523:usbdrv/usbdrv.c ****  * interrupt routine's transmit buffer is empty.
 524:usbdrv/usbdrv.c ****  */
 525:usbdrv/usbdrv.c **** static inline void usbBuildTxBlock(void)
 526:usbdrv/usbdrv.c **** {
 527:usbdrv/usbdrv.c **** usbMsgLen_t wantLen;
 528:usbdrv/usbdrv.c **** uchar       len;
 529:usbdrv/usbdrv.c **** 
 530:usbdrv/usbdrv.c ****     wantLen = usbMsgLen;
 531:usbdrv/usbdrv.c ****     if(wantLen > 8)
 532:usbdrv/usbdrv.c ****         wantLen = 8;
 533:usbdrv/usbdrv.c ****     usbMsgLen -= wantLen;
 534:usbdrv/usbdrv.c ****     usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 535:usbdrv/usbdrv.c ****     len = usbDeviceRead(usbTxBuf + 1, wantLen);
 536:usbdrv/usbdrv.c ****     if(len <= 8){           /* valid data packet */
 537:usbdrv/usbdrv.c ****         usbCrc16Append(&usbTxBuf[1], len);
GAS LISTING /tmp/ccupxjDr.s 			page 14


 538:usbdrv/usbdrv.c ****         len += 4;           /* length including sync byte */
 539:usbdrv/usbdrv.c ****         if(len < 12)        /* a partial package identifies end of message */
 540:usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 541:usbdrv/usbdrv.c ****     }else{
 542:usbdrv/usbdrv.c ****         len = USBPID_STALL;   /* stall the endpoint */
 543:usbdrv/usbdrv.c ****         usbMsgLen = USB_NO_MSG;
 544:usbdrv/usbdrv.c ****     }
 545:usbdrv/usbdrv.c ****     usbTxLen = len;
 546:usbdrv/usbdrv.c ****     DBG2(0x20, usbTxBuf, len-1);
 547:usbdrv/usbdrv.c **** }
 548:usbdrv/usbdrv.c **** 
 549:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 550:usbdrv/usbdrv.c **** 
 551:usbdrv/usbdrv.c **** static inline void usbHandleResetHook(uchar notResetState)
 552:usbdrv/usbdrv.c **** {
 553:usbdrv/usbdrv.c **** #ifdef USB_RESET_HOOK
 554:usbdrv/usbdrv.c **** static uchar    wasReset;
 555:usbdrv/usbdrv.c **** uchar           isReset = !notResetState;
 556:usbdrv/usbdrv.c **** 
 557:usbdrv/usbdrv.c ****     if(wasReset != isReset){
 558:usbdrv/usbdrv.c ****         USB_RESET_HOOK(isReset);
 559:usbdrv/usbdrv.c ****         wasReset = isReset;
 560:usbdrv/usbdrv.c ****     }
 561:usbdrv/usbdrv.c **** #endif
 562:usbdrv/usbdrv.c **** }
 563:usbdrv/usbdrv.c **** 
 564:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 565:usbdrv/usbdrv.c **** 
 566:usbdrv/usbdrv.c **** USB_PUBLIC void usbPoll(void)
 567:usbdrv/usbdrv.c **** {
 198               		.stabn	68,0,567,.LM10-.LFBB2
 199               	.LM10:
 200               	.LFBB2:
 201 0044 CF93      		push r28
 202 0046 DF93      		push r29
 203               	/* prologue: function */
 204               	/* frame size = 0 */
 205               	/* stack size = 2 */
 206               	.L__stack_usage = 2
 568:usbdrv/usbdrv.c **** schar   len;
 569:usbdrv/usbdrv.c **** uchar   i;
 570:usbdrv/usbdrv.c **** 
 571:usbdrv/usbdrv.c ****     len = usbRxLen - 3;
 207               		.stabn	68,0,571,.LM11-.LFBB2
 208               	.LM11:
 209 0048 6091 0000 		lds r22,usbRxLen
 210 004c 6350      		subi r22,lo8(-(-3))
 572:usbdrv/usbdrv.c ****     if(len >= 0){
 211               		.stabn	68,0,572,.LM12-.LFBB2
 212               	.LM12:
 213 004e 67FD      		sbrc r22,7
 214 0050 00C0      		rjmp .L8
 573:usbdrv/usbdrv.c **** /* We could check CRC16 here -- but ACK has already been sent anyway. If you
 574:usbdrv/usbdrv.c ****  * need data integrity checks with this driver, check the CRC in your app
 575:usbdrv/usbdrv.c ****  * code and report errors back to the host. Since the ACK was already sent,
 576:usbdrv/usbdrv.c ****  * retries must be handled on application level.
 577:usbdrv/usbdrv.c ****  * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
GAS LISTING /tmp/ccupxjDr.s 			page 15


 578:usbdrv/usbdrv.c ****  */
 579:usbdrv/usbdrv.c ****         usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
 215               		.stabn	68,0,579,.LM13-.LFBB2
 216               	.LM13:
 217 0052 8091 0000 		lds r24,usbInputBufOffset
 218 0056 CCE0      		ldi r28,lo8(12)
 219 0058 D0E0      		ldi r29,0
 220 005a C81B      		sub r28,r24
 221 005c D109      		sbc r29,__zero_reg__
 222 005e C050      		subi r28,lo8(-(usbRxBuf))
 223 0060 D040      		sbci r29,hi8(-(usbRxBuf))
 224               	.LBB50:
 225               	.LBB51:
 439:usbdrv/usbdrv.c ****         if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
 226               		.stabn	68,0,439,.LM14-.LFBB2
 227               	.LM14:
 228 0062 8091 0000 		lds r24,usbRxToken
 229 0066 8D32      		cpi r24,lo8(45)
 230 0068 01F0      		breq .+2
 231 006a 00C0      		rjmp .L9
 232               	.LBB52:
 440:usbdrv/usbdrv.c ****             return;
 233               		.stabn	68,0,440,.LM15-.LFBB2
 234               	.LM15:
 235 006c 6830      		cpi r22,lo8(8)
 236 006e 01F0      		breq .+2
 237 0070 00C0      		rjmp .L11
 443:usbdrv/usbdrv.c ****         usbTxLen = USBPID_NAK;              /* abort pending transmit */
 238               		.stabn	68,0,443,.LM16-.LFBB2
 239               	.LM16:
 240 0072 83EC      		ldi r24,lo8(-61)
 241 0074 8093 0000 		sts usbTxBuf,r24
 444:usbdrv/usbdrv.c ****         usbMsgFlags = 0;
 242               		.stabn	68,0,444,.LM17-.LFBB2
 243               	.LM17:
 244 0078 8AE5      		ldi r24,lo8(90)
 245 007a 8093 0000 		sts usbTxLen,r24
 445:usbdrv/usbdrv.c ****         uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
 246               		.stabn	68,0,445,.LM18-.LFBB2
 247               	.LM18:
 248 007e 1092 0000 		sts usbMsgFlags,__zero_reg__
 446:usbdrv/usbdrv.c ****         if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
 249               		.stabn	68,0,446,.LM19-.LFBB2
 250               	.LM19:
 251 0082 8881      		ld r24,Y
 252 0084 8076      		andi r24,lo8(96)
 447:usbdrv/usbdrv.c ****             replyLen = usbFunctionSetup(data);
 253               		.stabn	68,0,447,.LM20-.LFBB2
 254               	.LM20:
 255 0086 01F0      		breq .L12
 448:usbdrv/usbdrv.c **** 			// 2010.04.29 chrisc need this to work w/ usbtiny
 256               		.stabn	68,0,448,.LM21-.LFBB2
 257               	.LM21:
 258 0088 CE01      		movw r24,r28
 259 008a 00D0      		rcall usbFunctionSetup
 454:usbdrv/usbdrv.c ****             /* do some conditioning on replyLen, but on IN transfers only */
 260               		.stabn	68,0,454,.LM22-.LFBB2
GAS LISTING /tmp/ccupxjDr.s 			page 16


 261               	.LM22:
 262 008c 8F3F      		cpi r24,lo8(-1)
 263 008e 01F4      		brne .+2
 264 0090 00C0      		rjmp .L13
 265 0092 00C0      		rjmp .L14
 266               	.L12:
 267               	.LBB53:
 268               	.LBB54:
 365:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 269               		.stabn	68,0,365,.LM23-.LFBB2
 270               	.LM23:
 271 0094 9A81      		ldd r25,Y+2
 370:usbdrv/usbdrv.c ****     SWITCH_START(rq->bRequest)
 272               		.stabn	68,0,370,.LM24-.LFBB2
 273               	.LM24:
 274 0096 1092 0000 		sts usbTxBuf+9,__zero_reg__
 275               	.LBB55:
 371:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
 276               		.stabn	68,0,371,.LM25-.LFBB2
 277               	.LM25:
 278 009a 8981      		ldd r24,Y+1
 372:usbdrv/usbdrv.c ****         uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to
 279               		.stabn	68,0,372,.LM26-.LFBB2
 280               	.LM26:
 281 009c 8111      		cpse r24,__zero_reg__
 282 009e 00C0      		rjmp .L15
 283               	.LBB56:
 380:usbdrv/usbdrv.c ****         len = 2;
 284               		.stabn	68,0,380,.LM27-.LFBB2
 285               	.LM27:
 286 00a0 1092 0000 		sts usbTxBuf+10,__zero_reg__
 287               	.LBE56:
 288               	.LBE55:
 364:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 289               		.stabn	68,0,364,.LM28-.LFBB2
 290               	.LM28:
 291 00a4 20E0      		ldi r18,lo8(usbTxBuf+9)
 292 00a6 30E0      		ldi r19,hi8(usbTxBuf+9)
 293               	.LBB64:
 294               	.LBB57:
 381:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 295               		.stabn	68,0,381,.LM29-.LFBB2
 296               	.LM29:
 297 00a8 82E0      		ldi r24,lo8(2)
 298 00aa 00C0      		rjmp .L16
 299               	.L15:
 300               	.LBE57:
 389:usbdrv/usbdrv.c ****         usbNewDeviceAddr = value;
 301               		.stabn	68,0,389,.LM30-.LFBB2
 302               	.LM30:
 303 00ac 8530      		cpi r24,lo8(5)
 304 00ae 01F4      		brne .L17
 390:usbdrv/usbdrv.c ****         USB_SET_ADDRESS_HOOK();
 305               		.stabn	68,0,390,.LM31-.LFBB2
 306               	.LM31:
 307 00b0 9093 0000 		sts usbNewDeviceAddr,r25
 308 00b4 00C0      		rjmp .L52
GAS LISTING /tmp/ccupxjDr.s 			page 17


 309               	.L17:
 392:usbdrv/usbdrv.c ****         len = usbDriverDescriptor(rq);
 310               		.stabn	68,0,392,.LM32-.LFBB2
 311               	.LM32:
 312 00b6 8630      		cpi r24,lo8(6)
 313 00b8 01F4      		brne .L18
 314               	.LBE64:
 315               	.LBE54:
 316               	.LBE53:
 317               	.LBE52:
 318               	.LBE51:
 319               	.LBE50:
 362:usbdrv/usbdrv.c **** {
 320               		.stabn	68,0,362,.LM33-.LFBB2
 321               	.LM33:
 322 00ba 8B81      		ldd r24,Y+3
 323               	.LBB72:
 324               	.LBB71:
 325               	.LBB69:
 326               	.LBB68:
 327               	.LBB67:
 328               	.LBB65:
 329               	.LBB58:
 330               	.LBB59:
 331               	.LBB60:
 317:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 332               		.stabn	68,0,317,.LM34-.LFBB2
 333               	.LM34:
 334 00bc 8130      		cpi r24,lo8(1)
 335 00be 01F4      		brne .L19
 318:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 336               		.stabn	68,0,318,.LM35-.LFBB2
 337               	.LM35:
 338 00c0 80E0      		ldi r24,lo8(usbDescriptorDevice)
 339 00c2 90E0      		ldi r25,hi8(usbDescriptorDevice)
 340 00c4 9093 0000 		sts usbMsgPtr+1,r25
 341 00c8 8093 0000 		sts usbMsgPtr,r24
 342 00cc 82E1      		ldi r24,lo8(18)
 343 00ce 00C0      		rjmp .L20
 344               	.L19:
 319:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 345               		.stabn	68,0,319,.LM36-.LFBB2
 346               	.LM36:
 347 00d0 8230      		cpi r24,lo8(2)
 348 00d2 01F4      		brne .L21
 320:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 349               		.stabn	68,0,320,.LM37-.LFBB2
 350               	.LM37:
 351 00d4 80E0      		ldi r24,lo8(usbDescriptorConfiguration)
 352 00d6 90E0      		ldi r25,hi8(usbDescriptorConfiguration)
 353 00d8 9093 0000 		sts usbMsgPtr+1,r25
 354 00dc 8093 0000 		sts usbMsgPtr,r24
 355 00e0 89E1      		ldi r24,lo8(25)
 356 00e2 00C0      		rjmp .L20
 357               	.L21:
 321:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
 358               		.stabn	68,0,321,.LM38-.LFBB2
GAS LISTING /tmp/ccupxjDr.s 			page 18


 359               	.LM38:
 360 00e4 8330      		cpi r24,lo8(3)
 361 00e6 01F4      		brne .L49
 362               	.LBB61:
 328:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 363               		.stabn	68,0,328,.LM39-.LFBB2
 364               	.LM39:
 365 00e8 9111      		cpse r25,__zero_reg__
 366 00ea 00C0      		rjmp .L22
 329:usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 367               		.stabn	68,0,329,.LM40-.LFBB2
 368               	.LM40:
 369 00ec 80E0      		ldi r24,lo8(usbDescriptorString0)
 370 00ee 90E0      		ldi r25,hi8(usbDescriptorString0)
 371 00f0 9093 0000 		sts usbMsgPtr+1,r25
 372 00f4 8093 0000 		sts usbMsgPtr,r24
 373 00f8 84E0      		ldi r24,lo8(4)
 374 00fa 00C0      		rjmp .L20
 375               	.L22:
 332:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
 376               		.stabn	68,0,332,.LM41-.LFBB2
 377               	.LM41:
 378 00fc 9230      		cpi r25,lo8(2)
 379 00fe 01F4      		brne .L49
 333:usbdrv/usbdrv.c ****         SWITCH_CASE(3)
 380               		.stabn	68,0,333,.LM42-.LFBB2
 381               	.LM42:
 382 0100 80E0      		ldi r24,lo8(usbDescriptorStringDevice)
 383 0102 90E0      		ldi r25,hi8(usbDescriptorStringDevice)
 384 0104 9093 0000 		sts usbMsgPtr+1,r25
 385 0108 8093 0000 		sts usbMsgPtr,r24
 386 010c 86E1      		ldi r24,lo8(22)
 387 010e 00C0      		rjmp .L20
 388               	.L49:
 389               	.LBE61:
 390               	.LBE60:
 313:usbdrv/usbdrv.c **** uchar       flags = USB_FLG_MSGPTR_IS_ROM;
 391               		.stabn	68,0,313,.LM43-.LFBB2
 392               	.LM43:
 393 0110 80E0      		ldi r24,0
 394               	.L20:
 353:usbdrv/usbdrv.c ****     return len;
 395               		.stabn	68,0,353,.LM44-.LFBB2
 396               	.LM44:
 397 0112 90E4      		ldi r25,lo8(64)
 398 0114 9093 0000 		sts usbMsgFlags,r25
 399 0118 00C0      		rjmp .L14
 400               	.L18:
 401               	.LBE59:
 402               	.LBE58:
 395:usbdrv/usbdrv.c ****         dataPtr = &usbConfiguration;  /* send current configuration value */
 403               		.stabn	68,0,395,.LM45-.LFBB2
 404               	.LM45:
 405 011a 8830      		cpi r24,lo8(8)
 406 011c 01F0      		breq .L50
 398:usbdrv/usbdrv.c ****         usbConfiguration = value;
 407               		.stabn	68,0,398,.LM46-.LFBB2
GAS LISTING /tmp/ccupxjDr.s 			page 19


 408               	.LM46:
 409 011e 8930      		cpi r24,lo8(9)
 410 0120 01F4      		brne .L24
 399:usbdrv/usbdrv.c ****         usbResetStall();
 411               		.stabn	68,0,399,.LM47-.LFBB2
 412               	.LM47:
 413 0122 9093 0000 		sts usbConfiguration,r25
 414 0126 00C0      		rjmp .L52
 415               	.L24:
 401:usbdrv/usbdrv.c ****         len = 1;
 416               		.stabn	68,0,401,.LM48-.LFBB2
 417               	.LM48:
 418 0128 8A30      		cpi r24,lo8(10)
 419 012a 01F0      		breq .L51
 404:usbdrv/usbdrv.c ****         usbResetDataToggling();
 420               		.stabn	68,0,404,.LM49-.LFBB2
 421               	.LM49:
 422 012c 8B30      		cpi r24,lo8(11)
 423 012e 01F4      		brne .L52
 424               	.LBB62:
 425               	.LBB63:
 200:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
 426               		.stabn	68,0,200,.LM50-.LFBB2
 427               	.LM50:
 428 0130 8BE4      		ldi r24,lo8(75)
 429 0132 8093 0000 		sts usbTxStatus1+1,r24
 430 0136 00C0      		rjmp .L52
 431               	.L50:
 432               	.LBE63:
 433               	.LBE62:
 396:usbdrv/usbdrv.c ****         len = 1;
 434               		.stabn	68,0,396,.LM51-.LFBB2
 435               	.LM51:
 436 0138 20E0      		ldi r18,lo8(usbConfiguration)
 437 013a 30E0      		ldi r19,hi8(usbConfiguration)
 438 013c 00C0      		rjmp .L72
 439               	.L51:
 440               	.LBE65:
 364:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 441               		.stabn	68,0,364,.LM52-.LFBB2
 442               	.LM52:
 443 013e 20E0      		ldi r18,lo8(usbTxBuf+9)
 444 0140 30E0      		ldi r19,hi8(usbTxBuf+9)
 445               	.L72:
 446               	.LBB66:
 402:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 447               		.stabn	68,0,402,.LM53-.LFBB2
 448               	.LM53:
 449 0142 81E0      		ldi r24,lo8(1)
 450 0144 00C0      		rjmp .L16
 451               	.L52:
 452               	.LBE66:
 364:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 453               		.stabn	68,0,364,.LM54-.LFBB2
 454               	.LM54:
 455 0146 20E0      		ldi r18,lo8(usbTxBuf+9)
 456 0148 30E0      		ldi r19,hi8(usbTxBuf+9)
GAS LISTING /tmp/ccupxjDr.s 			page 20


 457 014a 80E0      		ldi r24,0
 458               	.L16:
 411:usbdrv/usbdrv.c **** skipMsgPtrAssignment:
 459               		.stabn	68,0,411,.LM55-.LFBB2
 460               	.LM55:
 461 014c 3093 0000 		sts usbMsgPtr+1,r19
 462 0150 2093 0000 		sts usbMsgPtr,r18
 463               	.L23:
 464 0154 00C0      		rjmp .L14
 465               	.L13:
 466               	.LBE67:
 467               	.LBE68:
 456:usbdrv/usbdrv.c ****                 if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing *
 468               		.stabn	68,0,456,.LM56-.LFBB2
 469               	.LM56:
 470 0156 9881      		ld r25,Y
 471 0158 97FD      		sbrc r25,7
 458:usbdrv/usbdrv.c ****                 }else{
 472               		.stabn	68,0,458,.LM57-.LFBB2
 473               	.LM57:
 474 015a 8E81      		ldd r24,Y+6
 475               	.L25:
 463:usbdrv/usbdrv.c ****         }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transf
 476               		.stabn	68,0,463,.LM58-.LFBB2
 477               	.LM58:
 478 015c 90E8      		ldi r25,lo8(-128)
 479 015e 9093 0000 		sts usbMsgFlags,r25
 480 0162 00C0      		rjmp .L26
 481               	.L14:
 467:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.bytes[0];
 482               		.stabn	68,0,467,.LM59-.LFBB2
 483               	.LM59:
 484 0164 9F81      		ldd r25,Y+7
 485 0166 9111      		cpse r25,__zero_reg__
 486 0168 00C0      		rjmp .L26
 487 016a 9E81      		ldd r25,Y+6
 488 016c 9817      		cp r25,r24
 489 016e 00F4      		brsh .L26
 490 0170 892F      		mov r24,r25
 491               	.L26:
 473:usbdrv/usbdrv.c ****     }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
 492               		.stabn	68,0,473,.LM60-.LFBB2
 493               	.LM60:
 494 0172 8093 0000 		sts usbMsgLen,r24
 495 0176 00C0      		rjmp .L11
 496               	.L9:
 497               	.LBE69:
 476:usbdrv/usbdrv.c ****             uchar rval = usbFunctionWrite(data, len);
 498               		.stabn	68,0,476,.LM61-.LFBB2
 499               	.LM61:
 500 0178 8091 0000 		lds r24,usbMsgFlags
 501 017c 87FF      		sbrs r24,7
 502 017e 00C0      		rjmp .L11
 503               	.LBB70:
 477:usbdrv/usbdrv.c ****             if(rval == 0xff){   /* an error occurred */
 504               		.stabn	68,0,477,.LM62-.LFBB2
 505               	.LM62:
GAS LISTING /tmp/ccupxjDr.s 			page 21


 506 0180 CE01      		movw r24,r28
 507 0182 00D0      		rcall usbFunctionWrite
 478:usbdrv/usbdrv.c ****                 usbTxLen = USBPID_STALL;
 508               		.stabn	68,0,478,.LM63-.LFBB2
 509               	.LM63:
 510 0184 8F3F      		cpi r24,lo8(-1)
 511 0186 01F4      		brne .L29
 479:usbdrv/usbdrv.c ****             }else if(rval != 0){    /* This was the final package */
 512               		.stabn	68,0,479,.LM64-.LFBB2
 513               	.LM64:
 514 0188 8EE1      		ldi r24,lo8(30)
 515 018a 8093 0000 		sts usbTxLen,r24
 516 018e 00C0      		rjmp .L11
 517               	.L29:
 480:usbdrv/usbdrv.c ****                 usbMsgLen = 0;  /* answer with a zero-sized data packet */
 518               		.stabn	68,0,480,.LM65-.LFBB2
 519               	.LM65:
 520 0190 8111      		cpse r24,__zero_reg__
 481:usbdrv/usbdrv.c ****             }
 521               		.stabn	68,0,481,.LM66-.LFBB2
 522               	.LM66:
 523 0192 1092 0000 		sts usbMsgLen,__zero_reg__
 524               	.L11:
 525               	.LBE70:
 526               	.LBE71:
 527               	.LBE72:
 580:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_FLOWCONTROL
 581:usbdrv/usbdrv.c ****         if(usbRxLen > 0)    /* only mark as available if not inactivated */
 582:usbdrv/usbdrv.c ****             usbRxLen = 0;
 583:usbdrv/usbdrv.c **** #else
 584:usbdrv/usbdrv.c ****         usbRxLen = 0;       /* mark rx buffer as available */
 528               		.stabn	68,0,584,.LM67-.LFBB2
 529               	.LM67:
 530 0196 1092 0000 		sts usbRxLen,__zero_reg__
 531               	.L8:
 585:usbdrv/usbdrv.c **** #endif
 586:usbdrv/usbdrv.c ****     }
 587:usbdrv/usbdrv.c ****     if(usbTxLen & 0x10){    /* transmit system idle */
 532               		.stabn	68,0,587,.LM68-.LFBB2
 533               	.LM68:
 534 019a 8091 0000 		lds r24,usbTxLen
 535 019e 84FF      		sbrs r24,4
 536 01a0 00C0      		rjmp .L30
 588:usbdrv/usbdrv.c ****         if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
 537               		.stabn	68,0,588,.LM69-.LFBB2
 538               	.LM69:
 539 01a2 8091 0000 		lds r24,usbMsgLen
 540 01a6 8F3F      		cpi r24,lo8(-1)
 541 01a8 01F4      		brne .+2
 542 01aa 00C0      		rjmp .L30
 543 01ac C82F      		mov r28,r24
 544 01ae 8930      		cpi r24,lo8(9)
 545 01b0 00F0      		brlo .L31
 546 01b2 C8E0      		ldi r28,lo8(8)
 547               	.L31:
 548               	.LBB73:
 549               	.LBB74:
GAS LISTING /tmp/ccupxjDr.s 			page 22


 533:usbdrv/usbdrv.c ****     usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 550               		.stabn	68,0,533,.LM70-.LFBB2
 551               	.LM70:
 552 01b4 8C1B      		sub r24,r28
 553 01b6 8093 0000 		sts usbMsgLen,r24
 534:usbdrv/usbdrv.c ****     len = usbDeviceRead(usbTxBuf + 1, wantLen);
 554               		.stabn	68,0,534,.LM71-.LFBB2
 555               	.LM71:
 556 01ba 8091 0000 		lds r24,usbTxBuf
 557 01be 98E8      		ldi r25,lo8(-120)
 558 01c0 8927      		eor r24,r25
 559 01c2 8093 0000 		sts usbTxBuf,r24
 560               	.LBB75:
 561               	.LBB76:
 495:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ
 562               		.stabn	68,0,495,.LM72-.LFBB2
 563               	.LM72:
 564 01c6 CC23      		tst r28
 565 01c8 01F0      		breq .L32
 497:usbdrv/usbdrv.c ****             len = usbFunctionRead(data, len);
 566               		.stabn	68,0,497,.LM73-.LFBB2
 567               	.LM73:
 568 01ca 8091 0000 		lds r24,usbMsgFlags
 569 01ce 87FF      		sbrs r24,7
 570 01d0 00C0      		rjmp .L33
 498:usbdrv/usbdrv.c ****         }else
 571               		.stabn	68,0,498,.LM74-.LFBB2
 572               	.LM74:
 573 01d2 6C2F      		mov r22,r28
 574 01d4 80E0      		ldi r24,lo8(usbTxBuf+1)
 575 01d6 90E0      		ldi r25,hi8(usbTxBuf+1)
 576 01d8 00D0      		rcall usbFunctionRead
 577 01da C82F      		mov r28,r24
 578               	.LBE76:
 579               	.LBE75:
 536:usbdrv/usbdrv.c ****         usbCrc16Append(&usbTxBuf[1], len);
 580               		.stabn	68,0,536,.LM75-.LFBB2
 581               	.LM75:
 582 01dc 8930      		cpi r24,lo8(9)
 583 01de 00F4      		brsh .L71
 584 01e0 00C0      		rjmp .L32
 585               	.L33:
 586               	.LBB81:
 587               	.LBB80:
 588               	.LBB77:
 502:usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 589               		.stabn	68,0,502,.LM76-.LFBB2
 590               	.LM76:
 591 01e2 4091 0000 		lds r20,usbMsgPtr
 592 01e6 5091 0000 		lds r21,usbMsgPtr+1
 503:usbdrv/usbdrv.c ****                 do{
 593               		.stabn	68,0,503,.LM77-.LFBB2
 594               	.LM77:
 595 01ea 86FF      		sbrs r24,6
 596 01ec 00C0      		rjmp .L35
 597 01ee A0E0      		ldi r26,lo8(usbTxBuf+1)
 598 01f0 B0E0      		ldi r27,hi8(usbTxBuf+1)
GAS LISTING /tmp/ccupxjDr.s 			page 23


 599 01f2 FA01      		movw r30,r20
 600 01f4 8C2F      		mov r24,r28
 601 01f6 8A0F      		add r24,r26
 602               	.L38:
 603               	.LBB78:
 604               	.LBB79:
 505:usbdrv/usbdrv.c ****                     *data++ = c;
 605               		.stabn	68,0,505,.LM78-.LFBB2
 606               	.LM78:
 607               	/* #APP */
 608               	 ;  505 "usbdrv/usbdrv.c" 1
 609 01f8 9491      		lpm r25, Z
 610               		
 611               	 ;  0 "" 2
 612               	/* #NOAPP */
 613               	.LBE79:
 506:usbdrv/usbdrv.c ****                     r++;
 614               		.stabn	68,0,506,.LM79-.LFBB2
 615               	.LM79:
 616 01fa 9D93      		st X+,r25
 507:usbdrv/usbdrv.c ****                 }while(--i);
 617               		.stabn	68,0,507,.LM80-.LFBB2
 618               	.LM80:
 619 01fc 3196      		adiw r30,1
 620               	.LBE78:
 508:usbdrv/usbdrv.c ****             }else{  /* RAM data */
 621               		.stabn	68,0,508,.LM81-.LFBB2
 622               	.LM81:
 623 01fe 8A13      		cpse r24,r26
 624 0200 00C0      		rjmp .L38
 625 0202 00C0      		rjmp .L73
 626               	.L35:
 627 0204 DA01      		movw r26,r20
 503:usbdrv/usbdrv.c ****                 do{
 628               		.stabn	68,0,503,.LM82-.LFBB2
 629               	.LM82:
 630 0206 E0E0      		ldi r30,lo8(usbTxBuf+1)
 631 0208 F0E0      		ldi r31,hi8(usbTxBuf+1)
 632 020a 8C2F      		mov r24,r28
 633 020c 8E0F      		add r24,r30
 634               	.L40:
 511:usbdrv/usbdrv.c ****                 }while(--i);
 635               		.stabn	68,0,511,.LM83-.LFBB2
 636               	.LM83:
 637 020e 9D91      		ld r25,X+
 638 0210 9193      		st Z+,r25
 512:usbdrv/usbdrv.c ****             }
 639               		.stabn	68,0,512,.LM84-.LFBB2
 640               	.LM84:
 641 0212 8E13      		cpse r24,r30
 642 0214 00C0      		rjmp .L40
 643               	.L73:
 644 0216 2FEF      		ldi r18,lo8(-1)
 645 0218 2C0F      		add r18,r28
 646 021a 30E0      		ldi r19,0
 647 021c 2F5F      		subi r18,-1
 648 021e 3F4F      		sbci r19,-1
GAS LISTING /tmp/ccupxjDr.s 			page 24


 649 0220 240F      		add r18,r20
 650 0222 351F      		adc r19,r21
 514:usbdrv/usbdrv.c ****         }
 651               		.stabn	68,0,514,.LM85-.LFBB2
 652               	.LM85:
 653 0224 3093 0000 		sts usbMsgPtr+1,r19
 654 0228 2093 0000 		sts usbMsgPtr,r18
 655               	.L32:
 656               	.LBE77:
 657               	.LBE80:
 658               	.LBE81:
 537:usbdrv/usbdrv.c ****         len += 4;           /* length including sync byte */
 659               		.stabn	68,0,537,.LM86-.LFBB2
 660               	.LM86:
 661 022c 6C2F      		mov r22,r28
 662 022e 80E0      		ldi r24,lo8(usbTxBuf+1)
 663 0230 90E0      		ldi r25,hi8(usbTxBuf+1)
 664 0232 00D0      		rcall usbCrc16Append
 538:usbdrv/usbdrv.c ****         if(len < 12)        /* a partial package identifies end of message */
 665               		.stabn	68,0,538,.LM87-.LFBB2
 666               	.LM87:
 667 0234 CC5F      		subi r28,lo8(-(4))
 539:usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 668               		.stabn	68,0,539,.LM88-.LFBB2
 669               	.LM88:
 670 0236 CC30      		cpi r28,lo8(12)
 671 0238 01F0      		breq .L41
 540:usbdrv/usbdrv.c ****     }else{
 672               		.stabn	68,0,540,.LM89-.LFBB2
 673               	.LM89:
 674 023a 8FEF      		ldi r24,lo8(-1)
 675 023c 8093 0000 		sts usbMsgLen,r24
 676 0240 00C0      		rjmp .L41
 677               	.L71:
 543:usbdrv/usbdrv.c ****     }
 678               		.stabn	68,0,543,.LM90-.LFBB2
 679               	.LM90:
 680 0242 8FEF      		ldi r24,lo8(-1)
 681 0244 8093 0000 		sts usbMsgLen,r24
 542:usbdrv/usbdrv.c ****         usbMsgLen = USB_NO_MSG;
 682               		.stabn	68,0,542,.LM91-.LFBB2
 683               	.LM91:
 684 0248 CEE1      		ldi r28,lo8(30)
 685               	.L41:
 545:usbdrv/usbdrv.c ****     DBG2(0x20, usbTxBuf, len-1);
 686               		.stabn	68,0,545,.LM92-.LFBB2
 687               	.LM92:
 688 024a C093 0000 		sts usbTxLen,r28
 689               	.L30:
 690               	.LBE74:
 691               	.LBE73:
 589:usbdrv/usbdrv.c ****             usbBuildTxBlock();
 590:usbdrv/usbdrv.c ****         }
 591:usbdrv/usbdrv.c ****     }
 592:usbdrv/usbdrv.c ****     for(i = 20; i > 0; i--){
 692               		.stabn	68,0,592,.LM93-.LFBB2
 693               	.LM93:
GAS LISTING /tmp/ccupxjDr.s 			page 25


 694 024e 84E1      		ldi r24,lo8(20)
 695               	.L44:
 696               	.LBB82:
 593:usbdrv/usbdrv.c ****         uchar usbLineStatus = USBIN & USBMASK;
 697               		.stabn	68,0,593,.LM94-.LFBB2
 698               	.LM94:
 699 0250 96B3      		in r25,0x16
 700 0252 9871      		andi r25,lo8(24)
 594:usbdrv/usbdrv.c ****         if(usbLineStatus != 0)  /* SE0 has ended */
 701               		.stabn	68,0,594,.LM95-.LFBB2
 702               	.LM95:
 703 0254 01F4      		brne .L42
 704               	.LBE82:
 592:usbdrv/usbdrv.c ****         uchar usbLineStatus = USBIN & USBMASK;
 705               		.stabn	68,0,592,.LM96-.LFBB2
 706               	.LM96:
 707 0256 8150      		subi r24,lo8(-(-1))
 708 0258 01F4      		brne .L44
 595:usbdrv/usbdrv.c ****             goto isNotReset;
 596:usbdrv/usbdrv.c ****     }
 597:usbdrv/usbdrv.c ****     /* RESET condition, called multiple times during reset */
 598:usbdrv/usbdrv.c ****     usbNewDeviceAddr = 0;
 709               		.stabn	68,0,598,.LM97-.LFBB2
 710               	.LM97:
 711 025a 1092 0000 		sts usbNewDeviceAddr,__zero_reg__
 599:usbdrv/usbdrv.c ****     usbDeviceAddr = 0;
 712               		.stabn	68,0,599,.LM98-.LFBB2
 713               	.LM98:
 714 025e 1092 0000 		sts usbDeviceAddr,__zero_reg__
 715               	.L42:
 716               	.LBB83:
 717               	.LBB84:
 555:usbdrv/usbdrv.c **** 
 718               		.stabn	68,0,555,.LM99-.LFBB2
 719               	.LM99:
 720 0262 C1E0      		ldi r28,lo8(1)
 721 0264 8111      		cpse r24,__zero_reg__
 722 0266 C0E0      		ldi r28,0
 723               	.L45:
 557:usbdrv/usbdrv.c ****         USB_RESET_HOOK(isReset);
 724               		.stabn	68,0,557,.LM100-.LFBB2
 725               	.LM100:
 726 0268 8091 0000 		lds r24,wasReset.1791
 727 026c 8C17      		cp r24,r28
 728 026e 01F0      		breq .L7
 558:usbdrv/usbdrv.c ****         wasReset = isReset;
 729               		.stabn	68,0,558,.LM101-.LFBB2
 730               	.LM101:
 731 0270 C111      		cpse r28,__zero_reg__
 732 0272 00C0      		rjmp .L47
 733 0274 00D0      		rcall usbEventResetReady
 734               	.L47:
 559:usbdrv/usbdrv.c ****     }
 735               		.stabn	68,0,559,.LM102-.LFBB2
 736               	.LM102:
 737 0276 C093 0000 		sts wasReset.1791,r28
 738               	.L7:
GAS LISTING /tmp/ccupxjDr.s 			page 26


 739               	/* epilogue start */
 740               	.LBE84:
 741               	.LBE83:
 600:usbdrv/usbdrv.c ****     usbResetStall();
 601:usbdrv/usbdrv.c ****     DBG1(0xff, 0, 0);
 602:usbdrv/usbdrv.c **** isNotReset:
 603:usbdrv/usbdrv.c ****     usbHandleResetHook(i);
 604:usbdrv/usbdrv.c **** }
 742               		.stabn	68,0,604,.LM103-.LFBB2
 743               	.LM103:
 744 027a DF91      		pop r29
 745 027c CF91      		pop r28
 746 027e 0895      		ret
 747               		.size	usbPoll, .-usbPoll
 748               		.stabs	"i:r(0,11)",64,0,569,24
 749               		.stabn	192,0,0,.LFBB2-.LFBB2
 750               		.stabs	"dataPtr:r(0,48)=*(0,11)",64,0,364,18
 751               		.stabs	"value:r(0,11)",64,0,365,25
 752               		.stabn	192,0,0,.LBB54-.LFBB2
 753               		.stabs	"_cmd:r(0,11)",64,0,371,24
 754               		.stabn	192,0,0,.LBB55-.LFBB2
 755               		.stabs	"_cmd:r(0,11)",64,0,316,24
 756               		.stabn	192,0,0,.LBB60-.LFBB2
 757               		.stabn	224,0,0,.LBE60-.LFBB2
 758               		.stabn	224,0,0,.LBE55-.LFBB2
 759               		.stabs	"_cmd:r(0,11)",64,0,371,24
 760               		.stabn	192,0,0,.LBB64-.LFBB2
 761               		.stabn	224,0,0,.LBE64-.LFBB2
 762               		.stabs	"_cmd:r(0,11)",64,0,371,24
 763               		.stabn	192,0,0,.LBB65-.LFBB2
 764               		.stabn	224,0,0,.LBE65-.LFBB2
 765               		.stabs	"_cmd:r(0,11)",64,0,371,24
 766               		.stabn	192,0,0,.LBB66-.LFBB2
 767               		.stabn	224,0,0,.LBE66-.LFBB2
 768               		.stabn	224,0,0,.LBE54-.LFBB2
 769               		.stabs	"dataPtr:r(0,48)",64,0,364,18
 770               		.stabs	"value:r(0,11)",64,0,365,25
 771               		.stabn	192,0,0,.LBB67-.LFBB2
 772               		.stabn	224,0,0,.LBE67-.LFBB2
 773               		.stabs	"rval:r(0,11)",64,0,477,24
 774               		.stabn	192,0,0,.LBB70-.LFBB2
 775               		.stabn	224,0,0,.LBE70-.LFBB2
 776               		.stabs	"isReset:r(0,11)",64,0,555,28
 777               		.stabn	192,0,0,.LBB84-.LFBB2
 778               		.stabn	224,0,0,.LBE84-.LFBB2
 779               		.stabn	224,0,0,.Lscope2-.LFBB2
 780               	.Lscope2:
 781               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 782               		.stabd	78,0,0
 783               		.stabs	"usbInit:F(0,47)",36,0,608,usbInit
 784               	.global	usbInit
 785               		.type	usbInit, @function
 786               	usbInit:
 787               		.stabd	46,0,0
 605:usbdrv/usbdrv.c **** 
 606:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 607:usbdrv/usbdrv.c **** 
GAS LISTING /tmp/ccupxjDr.s 			page 27


 608:usbdrv/usbdrv.c **** USB_PUBLIC void usbInit(void)
 609:usbdrv/usbdrv.c **** {
 788               		.stabn	68,0,609,.LM104-.LFBB3
 789               	.LM104:
 790               	.LFBB3:
 791               	/* prologue: function */
 792               	/* frame size = 0 */
 793               	/* stack size = 0 */
 794               	.L__stack_usage = 0
 610:usbdrv/usbdrv.c **** #if USB_INTR_CFG_SET != 0
 611:usbdrv/usbdrv.c ****     USB_INTR_CFG |= USB_INTR_CFG_SET;
 795               		.stabn	68,0,611,.LM105-.LFBB3
 796               	.LM105:
 797 0280 AB9A      		sbi 0x15,3
 612:usbdrv/usbdrv.c **** #endif
 613:usbdrv/usbdrv.c **** #if USB_INTR_CFG_CLR != 0
 614:usbdrv/usbdrv.c ****     USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
 615:usbdrv/usbdrv.c **** #endif
 616:usbdrv/usbdrv.c ****     USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
 798               		.stabn	68,0,616,.LM106-.LFBB3
 799               	.LM106:
 800 0282 8BB7      		in r24,0x3b
 801 0284 8062      		ori r24,lo8(32)
 802 0286 8BBF      		out 0x3b,r24
 803               	.LBB85:
 804               	.LBB86:
 200:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
 805               		.stabn	68,0,200,.LM107-.LFBB3
 806               	.LM107:
 807 0288 8BE4      		ldi r24,lo8(75)
 808 028a 8093 0000 		sts usbTxStatus1+1,r24
 809               	.LBE86:
 810               	.LBE85:
 617:usbdrv/usbdrv.c ****     usbResetDataToggling();
 618:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 619:usbdrv/usbdrv.c ****     usbTxLen1 = USBPID_NAK;
 811               		.stabn	68,0,619,.LM108-.LFBB3
 812               	.LM108:
 813 028e 8AE5      		ldi r24,lo8(90)
 814 0290 8093 0000 		sts usbTxStatus1,r24
 815 0294 0895      		ret
 816               		.size	usbInit, .-usbInit
 817               	.Lscope3:
 818               		.stabs	"",36,0,0,.Lscope3-.LFBB3
 819               		.stabd	78,0,0
 820               		.local	wasReset.1791
 821               		.comm	wasReset.1791,1,1
 822               	.global	usbDescriptorConfiguration
 823               		.section	.progmem.data,"a",@progbits
 824               		.type	usbDescriptorConfiguration, @object
 825               		.size	usbDescriptorConfiguration, 25
 826               	usbDescriptorConfiguration:
 827 0000 09        		.byte	9
 828 0001 02        		.byte	2
 829 0002 19        		.byte	25
 830 0003 00        		.byte	0
 831 0004 01        		.byte	1
GAS LISTING /tmp/ccupxjDr.s 			page 28


 832 0005 01        		.byte	1
 833 0006 00        		.byte	0
 834 0007 80        		.byte	-128
 835 0008 64        		.byte	100
 836 0009 09        		.byte	9
 837 000a 04        		.byte	4
 838 000b 00        		.byte	0
 839 000c 00        		.byte	0
 840 000d 01        		.byte	1
 841 000e FF        		.byte	-1
 842 000f 00        		.byte	0
 843 0010 00        		.byte	0
 844 0011 00        		.byte	0
 845 0012 07        		.byte	7
 846 0013 05        		.byte	5
 847 0014 81        		.byte	-127
 848 0015 03        		.byte	3
 849 0016 08        		.byte	8
 850 0017 00        		.byte	0
 851 0018 0A        		.byte	10
 852               	.global	usbDescriptorDevice
 853               		.type	usbDescriptorDevice, @object
 854               		.size	usbDescriptorDevice, 18
 855               	usbDescriptorDevice:
 856 0019 12        		.byte	18
 857 001a 01        		.byte	1
 858 001b 10        		.byte	16
 859 001c 01        		.byte	1
 860 001d 00        		.byte	0
 861 001e 00        		.byte	0
 862 001f 00        		.byte	0
 863 0020 08        		.byte	8
 864 0021 81        		.byte	-127
 865 0022 17        		.byte	23
 866 0023 9F        		.byte	-97
 867 0024 0C        		.byte	12
 868 0025 04        		.byte	4
 869 0026 01        		.byte	1
 870 0027 00        		.byte	0
 871 0028 02        		.byte	2
 872 0029 00        		.byte	0
 873 002a 01        		.byte	1
 874               	.global	usbDescriptorStringDevice
 875               		.type	usbDescriptorStringDevice, @object
 876               		.size	usbDescriptorStringDevice, 22
 877               	usbDescriptorStringDevice:
 878 002b 1603      		.word	790
 879 002d 5500      		.word	85
 880 002f 5300      		.word	83
 881 0031 4200      		.word	66
 882 0033 7400      		.word	116
 883 0035 6900      		.word	105
 884 0037 6E00      		.word	110
 885 0039 7900      		.word	121
 886 003b 5300      		.word	83
 887 003d 5000      		.word	80
 888 003f 4900      		.word	73
GAS LISTING /tmp/ccupxjDr.s 			page 29


 889               	.global	usbDescriptorString0
 890               		.type	usbDescriptorString0, @object
 891               		.size	usbDescriptorString0, 4
 892               	usbDescriptorString0:
 893 0041 04        		.byte	4
 894 0042 03        		.byte	3
 895 0043 09        		.byte	9
 896 0044 04        		.byte	4
 897               		.local	usbMsgFlags
 898               		.comm	usbMsgFlags,1,1
 899               		.data
 900               		.type	usbMsgLen, @object
 901               		.size	usbMsgLen, 1
 902               	usbMsgLen:
 903 0000 FF        		.byte	-1
 904               		.comm	usbMsgPtr,2,1
 905               		.comm	usbTxStatus1,12,1
 906               		.comm	usbTxBuf,11,1
 907               	.global	usbTxLen
 908               		.type	usbTxLen, @object
 909               		.size	usbTxLen, 1
 910               	usbTxLen:
 911 0001 5A        		.byte	90
 912               		.comm	usbRxToken,1,1
 913               		.comm	usbCurrentTok,1,1
 914               		.comm	usbRxLen,1,1
 915               		.comm	usbConfiguration,1,1
 916               		.comm	usbNewDeviceAddr,1,1
 917               		.comm	usbDeviceAddr,1,1
 918               		.comm	usbInputBufOffset,1,1
 919               		.comm	usbRxBuf,22,1
 920               		.stabs	"usbMsgLen:S(0,11)",38,0,49,usbMsgLen
 921               		.stabs	"usbMsgFlags:S(0,11)",40,0,50,usbMsgFlags
 922               		.stabs	"usbMsgPtr:G(0,48)",32,0,48,0
 923               		.stabs	"usbRxToken:G(0,11)",32,0,31,0
 924               		.stabs	"usbConfiguration:G(0,11)",32,0,28,0
 925               		.stabs	"usbDescriptorDevice:G(0,49)=ar(10,4);0;17;(0,50)=k(0,2)",32,0,111,0
 926               		.stabs	"usbDescriptorConfiguration:G(0,51)=ar(10,4);0;24;(0,50)",32,0,142,0
 927               		.stabs	"usbDescriptorString0:G(0,52)=ar(10,4);0;3;(0,50)",32,0,70,0
 928               		.stabs	"usbDescriptorStringDevice:G(0,53)=ar(10,4);0;10;(0,54)=k(0,1)",32,0,89,0
 929               		.stabs	"usbTxStatus1:G(10,5)",32,0,38,0
 930               		.stabs	"usbRxBuf:G(0,55)=ar(10,4);0;21;(0,11)",32,0,24,0
 931               		.stabs	"usbInputBufOffset:G(0,11)",32,0,25,0
 932               		.stabs	"usbDeviceAddr:G(0,11)",32,0,26,0
 933               		.stabs	"usbNewDeviceAddr:G(0,11)",32,0,27,0
 934               		.stabs	"usbRxLen:G(0,56)=B(0,10)",32,0,29,0
 935               		.stabs	"usbCurrentTok:G(0,11)",32,0,30,0
 936               		.stabs	"usbTxLen:G(10,2)",32,0,32,0
 937               		.stabs	"usbTxBuf:G(10,3)",32,0,33,0
 938               		.text
 939               		.stabs	"",100,0,0,.Letext0
 940               	.Letext0:
 941               		.ident	"GCC: (GNU) 4.8.1"
 942               	.global __do_copy_data
 943               	.global __do_clear_bss
GAS LISTING /tmp/ccupxjDr.s 			page 30


DEFINED SYMBOLS
                            *ABS*:0000000000000000 usbdrv.c
     /tmp/ccupxjDr.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccupxjDr.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccupxjDr.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccupxjDr.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccupxjDr.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccupxjDr.s:121    .text:0000000000000000 usbSetInterrupt
                            *COM*:000000000000000c usbTxStatus1
     /tmp/ccupxjDr.s:196    .text:0000000000000044 usbPoll
                            *COM*:0000000000000001 usbRxLen
                            *COM*:0000000000000001 usbInputBufOffset
                            *COM*:0000000000000016 usbRxBuf
                            *COM*:0000000000000001 usbRxToken
                            *COM*:000000000000000b usbTxBuf
     /tmp/ccupxjDr.s:910    .data:0000000000000001 usbTxLen
     /tmp/ccupxjDr.s:821    .bss:0000000000000001 usbMsgFlags
                            *COM*:0000000000000001 usbNewDeviceAddr
     /tmp/ccupxjDr.s:855    .progmem.data:0000000000000019 usbDescriptorDevice
                            *COM*:0000000000000002 usbMsgPtr
     /tmp/ccupxjDr.s:826    .progmem.data:0000000000000000 usbDescriptorConfiguration
     /tmp/ccupxjDr.s:892    .progmem.data:0000000000000041 usbDescriptorString0
     /tmp/ccupxjDr.s:877    .progmem.data:000000000000002b usbDescriptorStringDevice
                            *COM*:0000000000000001 usbConfiguration
     /tmp/ccupxjDr.s:902    .data:0000000000000000 usbMsgLen
                            *COM*:0000000000000001 usbDeviceAddr
                             .bss:0000000000000000 wasReset.1791
     /tmp/ccupxjDr.s:786    .text:0000000000000280 usbInit
                            *COM*:0000000000000001 usbCurrentTok

UNDEFINED SYMBOLS
usbCrc16Append
usbFunctionSetup
usbFunctionWrite
usbFunctionRead
usbEventResetReady
__do_copy_data
__do_clear_bss
